import numpy as np
import torch
import lal
from bilby.core.prior import PriorDict


class GNPEShiftDetectorTimes(object):
    """
    GNPE [1] Transformation for detector times.

    For each of the detector times, a proxy is generated by adding a
    perturbation epsilon from the gnpe kernel to the true detector time. This
    proxy is subtracted from the detector time, such that the overall time
    shift only amounts to -epsilon in training. This standardizes the input data
    to the inference network, since the applied time shifts are always restricted
    to the range of the kernel.

    To preserve information at inference time, conditioning of the inference
    network on the proxies is required. To that end, the proxies are stored
    in sample['gnpe_proxies'].

    We can enforce an exact equivariance under global time translations,
    by subtracting one proxy (by convention: the first one, usually for H1
    ifo) from all other proxies, and from the geocent time, see [1]. This is
    enabled with the flag exact_global_equivariance.

    [1]: arxiv.org/abs/2111.13139
    """

    def __init__(
        self, ifo_list, kernel, exact_global_equivariance=True, inference=True
    ):
        """
        ifo_list : bilby.gw.detector.InterferometerList
            List of interferometers.
            Todo: this should maybe just be a list of strings instead of a bilby IfoList?
        kernel : str
            Defines a Bilby prior.
        exact_global_equivariance : bool = True
            Whether to impose the exact global time translation symmetry.
            (Default True)
        inference: bool = True
            Whether to use inference mode or not
        """
        self.ifo_names = [ifo.name for ifo in ifo_list]
        self.kernel = None
        self.set_kernel(kernel)
        self.exact_global_equivariance = exact_global_equivariance
        self.inference = inference

    def __call__(self, input_sample):
        sample = input_sample.copy()
        # Copy extrinsic parameters to not overwrite input_sample. Does this really
        # matter?
        extrinsic_parameters = sample["extrinsic_parameters"].copy()

        proxies = {}
        num_samples = len(extrinsic_parameters[f"{self.ifo_names[0]}_time"])
        epsilon = self.kernel.sample(num_samples)
        for ifo_name in self.ifo_names:
            t = extrinsic_parameters[f"{ifo_name}_time"]
            if type(t) == torch.Tensor:
                eps = torch.tensor(epsilon[ifo_name], dtype=t.dtype, device=t.device)
            else:
                eps = np.float32(epsilon[ifo_name])
            t_hat = t + eps
            proxies[f"{ifo_name}_time_proxy"] = t_hat
            # time shifts to the strain data are applied in a following transformation,
            # store the time shifts in extrinsic_parameters[f"{ifo_name}_time"]
            if not self.inference:
                # at train time, two time shifts need to be applied:
                #   1) the time shift by t for the detector projection
                #   2) the time shift by - t_hat for gnpe
                # we combine these to one shift by t - t_hat for efficiency
                extrinsic_parameters[f"{ifo_name}_time"] = t - t_hat
            else:
                # at inference time, the data is already projected onto the detector,
                # so only the gnpe time shift by - t_hat needs to be applied
                extrinsic_parameters[f"{ifo_name}_time"] = -t_hat

        # If we are imposing the global time shift symmetry, then we treat the first
        # proxy as "preferred", in the sense that it defines the global time shift.
        # This symmetry is enforced as follows:
        #
        #    1) Do not explicitly condition the model on the preferred proxy
        #    2) Subtract the preferred proxy from geocent_time (assumed to be a regression
        #    parameter). Note that this must be undone at inference time.
        #    3) Subtract the preferred proxy from the remaining proxies. These remaining
        #    proxies then define time shifts relative to the global time shift.
        #
        # Imposing the global time shift does not impact the transformation of the
        # data: we do not change the values of the true detector coalescence times
        # stored in extrinsic_parameters, only the proxies.

        if self.exact_global_equivariance:
            dt = proxies.pop(f"{self.ifo_names[0]}_time_proxy")
            if "geocent_time" in extrinsic_parameters:
                extrinsic_parameters["geocent_time"] -= dt
            else:
                extrinsic_parameters["geocent_time"] = -dt  # for gnpe inference
            for ifo_name in proxies.keys():
                proxies[ifo_name] -= dt

        # Include the proxy variables along with the extrinsic parameters; they have
        # unique names (ending in "_proxy") so they will not be confused.
        extrinsic_parameters.update(proxies)
        sample["extrinsic_parameters"] = extrinsic_parameters
        return sample

    def set_kernel(self, kernel_str):
        """
        Set the GNPE kernel based on a Bilby prior string. This uses the same kernel
        for each interferometers.

        Parameters
        ----------
        kernel_str : str
            Defines a bilby prior, e.g.,
            'bilby.core.prior.Uniform(minimum=-0.001, maximum=0.001)'
        """
        prior_dict = {ifo: kernel_str for ifo in self.ifo_names}
        self.kernel = PriorDict(prior_dict)

    def get_context_parameters(self):
        """
        Provides a list of parameters on which the GNPE posterior should be conditioned.
        These are the blurred coalescence times in each detector, e.g.,

        ['H1_time_proxy', 'L1_time_proxy', 'V1_time_proxy']

        If we enforce an exact time translation symmetry (typical use case), then the first
        interferometer is dropped.

        This function is useful in determining the list of proxies outside of constructing
        the transform.

        Returns
        -------
        list[str]
            The parameter names.
        """
        proxy_list = [f"{name}_time_proxy" for name in self.ifo_names]
        if self.exact_global_equivariance:
            return proxy_list[1:]
        else:
            return proxy_list


class GNPEChirpMass(object):
    """
    GNPE [1] Transformation for chirp mass.

    Todo

    [1]: arxiv.org/abs/2111.13139
    """

    def __init__(self, frequencies, kernel_kwargs):
        """
        :param frequencies: np.array
            sample frequencies of strain data
        :param kernel_kwargs: dict
            kwargs for gnpe kernel
        :param mean: float = 0
            mean for standardization of proxy
        :param std: float = 1
            standard deviation for standardization of proxy
        """
        self.f = frequencies
        self.kernel = get_gnpe_kernel(kernel_kwargs)

    def __call__(self, input_sample):
        sample = input_sample.copy()
        # Copy extrinsic parameters to not overwrite input_sample. Does this really
        # matter?
        extrinsic_parameters = sample["extrinsic_parameters"].copy()

        # get proxy by adding perturbation from kernel to Mc
        Mc_hat = sample["parameters"]["chirp_mass"] + self.kernel()
        # convert to SI units
        Mc_SI_hat = Mc_hat * lal.GMSUN_SI

        rescaling = np.exp(
            1j
            * (3 / 4)
            * (8 * np.pi * self.f * (Mc_SI_hat / lal.C_SI ** 3)) ** (-5 / 3)
        )
        hc = sample["waveform"]["h_cross"] * rescaling
        hp = sample["waveform"]["h_plus"] * rescaling
        sample["waveform"] = {"h_cross": hc, "h_plus": hp}

        extrinsic_parameters.update({"chirp_mass_proxy": Mc_hat})
        sample["extrinsic_parameters"] = extrinsic_parameters

        # proxies_array = (np.array([Mc_hat]) - self.mean) / self.std
        # if "gnpe_proxies" in sample:
        #     sample["gnpe_proxies"] = np.concatenate(
        #         (sample["gnpe_proxies"], proxies_array)
        #     )
        # else:
        #     sample["gnpe_proxies"] = proxies_array
        return sample


def get_gnpe_kernel(kernel_kwargs):
    """
    Returns kernel from kernel_kwargs.

    :param kernel_kwargs: dict
        kernel_kwargs['type'] contains the type of the kernel (choices:
        'uniform' and 'random'). The remaining kwargs are passed to the
        corresponding numpy function.
    :return: kernel
    """
    # kernel_type = kernel_kwargs.pop('type')
    kernel_type = kernel_kwargs["type"]
    kernel_kwargs = {k: v for k, v in kernel_kwargs.items() if k != "type"}
    if kernel_type == "uniform":

        def kernel():
            return np.random.uniform(**kernel_kwargs)

        return kernel
    elif kernel_type == "normal":

        def kernel():
            return np.random.normal(**kernel_kwargs)

        return kernel
    else:
        raise NotImplementedError(f"Unknown kernel type {kernel_type}.")
