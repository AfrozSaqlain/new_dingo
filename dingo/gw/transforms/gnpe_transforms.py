import numpy as np
import lal

class GNPEDetectorTimes(object):
    """
    GNPE [1] Transformation for detector times.

    For each of the detector times, a proxy is generated by adding a
    perturbation epsilon from the gnpe kernel to the true detector time. This
    proxy is subtracted from the detector time, such that the overall time
    shift only amounts to -epsilon. This standardizes the input data to the
    inference network, since the applied time shifts are always restricted to
    the range of the kernel.

    To preserve information at inference time, conditioning of the inference
    network on the proxies is required. To that end, the proxies are stored
    in sample['gnpe_proxies'].

    We can enforce an exact equivariance under global time translations,
    by subtracting one proxy (by convention: the first one, usually for H1
    ifo) from all other proxies, and from the geocent time, see [1]. This is
    enabled with the flag exact_global_equivariance.

    [1]: arxiv.org/abs/2111.13139
    """
    def __init__(self, ifo_list, kernel_kwargs, exact_global_equivariance=True,
                 mean=0, std=1):
        """
        :param ifo_list: bilby.gw.detector.InterferometerList
            list of detectors
        :param kernel_kwargs: dict
            kwargs for gnpe kernel
        :param exact_global_equivariance: bool = True
            flag whether exact equivariance under global time translations is
        :param mean: float = 0
            mean for standardization of proxies
        :param std: float = 1
            standard deviation for standardization of proxies
        """
        self.ifo_names = [ifo.name for ifo in ifo_list]
        self.kernel = get_gnpe_kernel(kernel_kwargs)
        self.exact_global_equivariance = exact_global_equivariance
        # one proxy for each ifo; one less, if exact equivariance under
        # global time translations is enforced
        self.gnpe_proxy_dim = len(ifo_list) - int(exact_global_equivariance)
        self.mean = mean
        self.std = std

    def __call__(self, input_sample):
        sample = input_sample.copy()
        # copy extrinsic parameters to not overwrite input_sample
        ext_params = sample['extrinsic_parameters'].copy()
        proxies = {}
        # sample kernel for each ifo
        for ifo_name in self.ifo_names:
            t = ext_params[f'{ifo_name}_time']
            t_hat = t + self.kernel()
            proxies[f'{ifo_name}_time_proxy'] = t_hat
            ext_params[f'{ifo_name}_time'] -= t_hat
        # potentially enforce exact global equivariance by subtracting the
        # first proxy from all proxies, and from geocent_time
        if self.exact_global_equivariance:
            # get first proxy
            dt = proxies.pop(f'{self.ifo_names[0]}_time_proxy')
            # subtract it from geocent_time
            if 'geocent_time' in ext_params:
                ext_params['geocent_time'] -= dt
            # subtract it from remaining proxies
            for ifo_name in proxies.keys():
                proxies[ifo_name] -= dt
        # update extrinsic parameters with shifted times,
        sample['extrinsic_parameters'] = ext_params
        # store standardized proxies in sample
        proxies_array = \
            (np.array([proxies[k] for k in proxies]) - self.mean) / self.std
        if 'gnpe_proxies' in sample:
            sample['gnpe_proxies'] = np.concatenate(
                (sample['gnpe_proxies'], proxies_array))
        else:
            sample['gnpe_proxies'] = proxies_array
        return sample


class GNPEChirpMass(object):
    """
    GNPE [1] Transformation for chirp mass.

    Todo

    [1]: arxiv.org/abs/2111.13139
    """
    def __init__(self, frequencies, kernel_kwargs, mean=0, std=1):
        """
        :param frequencies: np.array
            sample frequencies of strain data
        :param kernel_kwargs: dict
            kwargs for gnpe kernel
        :param mean: float = 0
            mean for standardization of proxy
        :param std: float = 1
            standard deviation for standardization of proxy
        """
        self.f = frequencies
        self.kernel = get_gnpe_kernel(kernel_kwargs)
        self.gnpe_proxy_dim = 1
        self.mean = mean
        self.std = std

    def __call__(self, input_sample):
        sample = input_sample.copy()

        # get proxy by adding perturbation from kernel to Mc
        Mc_hat = sample['parameters']['chirp_mass'] + self.kernel()
        # convert to SI units
        Mc_SI_hat = Mc_hat * lal.GMSUN_SI

        rescaling = np.exp(1j * (3 / 4) * (
                8 * np.pi * self.f * (Mc_SI_hat / lal.C_SI ** 3)) ** (-5 / 3))
        hc = sample['waveform']['h_cross'] * rescaling
        hp = sample['waveform']['h_plus'] * rescaling
        sample['waveform'] = {'h_cross': hc, 'h_plus': hp}

        proxies_array = (np.array([Mc_hat]) - self.mean) / self.std
        if 'gnpe_proxies' in sample:
            sample['gnpe_proxies'] = np.concatenate(
                (sample['gnpe_proxies'], proxies_array))
        else:
            sample['gnpe_proxies'] = proxies_array
        return sample


def get_gnpe_kernel(kernel_kwargs):
    """
    Returns kernel from kernel_kwargs.

    :param kernel_kwargs: dict
        kernel_kwargs['type'] contains the type of the kernel (choices:
        'uniform' and 'random'). The remaining kwargs are passed to the
        corresponding numpy function.
    :return: kernel
    """
    kernel_type = kernel_kwargs.pop('type')
    if kernel_type == 'uniform':
        def kernel():
            return np.random.uniform(**kernel_kwargs)
        return kernel
    elif kernel_type == 'normal':
        def kernel():
            return np.random.normal(**kernel_kwargs)
        return kernel
    else:
        raise NotImplementedError(f'Unknown kernel type {kernel_type}.')