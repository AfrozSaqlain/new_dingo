import numpy as np
from scipy.signal import tukey
from torchvision.transforms import Compose
from dingo.gw.prior import default_extrinsic_dict
from dingo.gw.prior import BBHExtrinsicPriorDict
from dingo.gw.transforms import SampleExtrinsicParameters, GetDetectorTimes


def find_axis(array, dim):
    """Looks for axis with dimension dim in array, and returns its index."""
    indices = np.where(np.array(array.shape) == dim)[0]
    if len(indices) > 1:
        raise ValueError(
            f"Automatic axis detection ambiguous. Array of shape "
            f"{array.shape} has {len(indices)} axes of dimension "
            f"{dim}."
        )
    if len(indices) < 1:
        raise ValueError(
            f"Automatic axis detection failed. Array of shape "
            f"{array.shape} has no axis of dimension {dim}."
        )
    else:
        return indices[0]


def truncate_array(array, axis, lower, upper):
    """Truncate array to [lower:upper] along selected axis."""
    sl = [slice(None)] * array.ndim
    sl[axis] = slice(lower, upper)
    return array[tuple(sl)]


def get_window(window_kwargs):
    """Compute window from window_kwargs."""
    type = window_kwargs["type"]
    if type == "tukey":
        roll_off, T, f_s = (
            window_kwargs["roll_off"],
            window_kwargs["T"],
            window_kwargs["f_s"],
        )
        alpha = 2 * roll_off / T
        w = tukey(int(T * f_s), alpha)
        return w
    else:
        raise NotImplementedError(f"Unknown window type {type}.")


def get_window_factor(window):
    """
    TODO
    Parameters
    ----------
    window

    Returns
    -------

    """
    """Compute window factor."""
    if type(window) == dict:
        window = get_window(window)
    return np.sum(window ** 2) / len(window)


def get_extrinsic_prior_dict(extrinsic_prior):
    """Build dict for extrinsic prior by starting with
    default_extrinsic_dict, and overwriting every element for which
    extrinsic_prior is not default."""
    extrinsic_prior_dict = default_extrinsic_dict.copy()
    for k, v in extrinsic_prior.items():
        if v.lower() != "default":
            extrinsic_prior_dict[k] = v
    return extrinsic_prior_dict


def get_detectortimes_mean_std(
    selected_parameters,
    extrinsic_prior_dict,
    ifo_list,
    ref_time,
):
    """
    Compute the mean and standardization for the detectortimes numerically.
    Samples for the detectortimes are generated by sampling from the extrinsic prior
    and computing the corresponding detectortimes.

    Parameters
    ----------
    selected_parameters:
        list of selected parameters to determine which detectortimes are required
    extrinsic_prior_dict:
        dict with extrinsic prior
    ifo_list:
        InterferometerList
    ref_time:
        reference time

    Returns
    -------
    mean, std:
        dicts with means and stds for the detectortimes
    """
    detector_times = [
        p
        for p in selected_parameters
        if p.endswith("_time") and not p[:-5] == "geocent"
    ]

    if len(detector_times) == 0:
        return {}, {}

    else:
        transform = Compose(
            [
                SampleExtrinsicParameters(extrinsic_prior_dict),
                GetDetectorTimes(ifo_list, ref_time=ref_time),
            ]
        )
        N = 20_000
        samples = {p: np.empty(N) for p in detector_times}
        for idx in range(N):
            sample = transform({})
            for p in detector_times:
                samples[p][idx] = sample["extrinsic_parameters"][p]

        mean = {p: np.mean(samples[p]) for p in detector_times}
        std = {p: np.std(samples[p]) for p in detector_times}

        # typically, the mean of the detectortimes should be 0
        for p in detector_times:
            assert (
                abs(mean[p]) < 0.1 * std[p]
            ), "Mean is non-zero, check the prior on sky position and geocent time"
            mean[p] = 0

        return mean, std


def get_standardization_dict(
    extrinsic_prior_dict, wfd, selected_parameters, ifo_list=None, ref_time=None
):
    # get mean and std for extrinsic prior
    ext_prior = BBHExtrinsicPriorDict(extrinsic_prior_dict)
    mean_extrinsic, std_extrinsic = ext_prior.mean_std(ext_prior.keys())
    # get mean and std for intrinsic prior
    mean_intrinsic, std_intrinsic = wfd.parameter_mean_std()
    # mean_intrinsic = {k: np.mean(wfd._parameter_samples[k]) for k in
    #                   wfd._parameter_samples.keys()}
    # std_intrinsic = {k: np.std(wfd._parameter_samples[k]) for k in
    #                  wfd._parameter_samples.keys()}
    # check that overlap between intrinsic and extrinsic parameters is only
    # due to fiducial values (-> std 0)
    for k in std_intrinsic.keys() & std_extrinsic.keys():
        assert std_intrinsic[k] == 0

    # if detector times are in selected parameters, the standardizations for these are
    # computed numerically
    mean_detectortimes, std_detectortimes = get_detectortimes_mean_std(
        selected_parameters, extrinsic_prior_dict, ifo_list, ref_time
    )

    # merge dicts, overwriting fiducial values for parameters (e.g.,
    # luminosity_distance) in intrinsic parameters by the extrinsic ones
    mean = {**mean_intrinsic, **mean_extrinsic, **mean_detectortimes}
    std = {**std_intrinsic, **std_extrinsic, **std_detectortimes}

    # return standardization dict
    standardization_dict = {
        "mean": {k: mean[k] for k in selected_parameters},
        "std": {k: std[k] for k in selected_parameters},
    }
    return standardization_dict
