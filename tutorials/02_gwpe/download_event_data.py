import os
from os.path import join
import numpy as np
import torchvision
import matplotlib.pyplot as plt
import json
import h5py
from pathlib import Path
import argparse

from scipy.signal import tukey

from gwpy.timeseries import TimeSeries
import pycbc.psd

from dingo.gw.gwutils import get_window, get_window_factor, save_dataset, \
    recursive_hdf5_load
from dingo.gw.domains import UniformFrequencyDomain, build_domain
from dingo.gw.transforms import WhitenAndScaleStrain




def download_psd(det, time_start, time_segment, window, num_segments: int = 128):
    """
    Download strain data and generate a PSD based on these. Use num_segments of length
    time_segment, starting at GPS time time_start.

    Parameters
    ----------
    det: str
        detector
    time_start: float
        start GPS time for PSD estimation
    time_segment: float
        time for a single segment for PSD information, in seconds
    window: Union(np.ndarray, dict)
        Window used for PSD generation, needs to be the same as used for Fourier
        transform of event strain data.
        Either provided directly as np.ndarray, or as dict in which case the window is
        generated by window = dingo.gw.gwutils.get_window(**window).
    num_segments: int = 256
        number of segments used for PSD generation

    Returns
    -------
    psd: np.array
        array of psd
    """
    # download strain data for psd
    print('Downloading strain data for PSD estimation.', end=' ')
    time_end = time_start + time_segment * num_segments
    psd_strain = TimeSeries.fetch_open_data(det, time_start, time_end, cache=True)
    print('Done.')
    psd_strain = psd_strain.to_pycbc()

    # optionally generate window
    if type(window) == dict:
        window = get_window(**window)
    assert len(window) == len(psd_strain) / num_segments, \
        "Window does not match strain. Is sampling frequency f_s off?"

    # generate PSD from strain data
    psd = pycbc.psd.estimate.welch(
        psd_strain, seg_len=len(window), seg_stride=len(window), window=window,
        avg_method='median',
    )

    return np.array(psd)

def download_strain_data_in_FD(det, time_event, time_segment, time_buffer, window):
    """
    Download strain data for a GW event at GPS time time_event. The segment is
    time_segment seconds long, including time_buffer seconds after the event. The
    strain is Fourier transformed, the frequency domain strain is then time shifted by
    time_buffer, such that the event occurs at t=0.

    Parameters
    ----------
    det: str
        detector
    time_event: float
        GPS time of the event
    time_segment: float
        length of the strain segment, in seconds
    time_buffer: float
        specifies buffer time after time_event, in seconds
    window: Union(np.ndarray, dict)
        Window used for Fourier transforming the event strain data.
        Either provided directly as np.ndarray, or as dict in which case the window is
        generated by window = dingo.gw.gwutils.get_window(**window).


    Returns
    -------
    event_strain: np.array
        array with the frequency domain strain
    """
    # download strain data
    print('Downloading strain data for event.', end=' ')
    event_strain = TimeSeries.fetch_open_data(
        det, time_event + time_buffer - time_segment, time_event + time_buffer,
        cache=True)
    print('Done.')

    # transform to FD
    if type(window) == dict:
        window = get_window(**window)
    assert len(window) == len(event_strain), \
        "Window does not match strain. Is sampling frequency f_s off?"
    event_strain = event_strain.to_pycbc()
    event_strain = (event_strain * window).to_frequencyseries()

    # time shift by time_buffer, such that event happens at time 0
    event_strain = event_strain.cyclic_time_shift(time_buffer)

    return np.array(event_strain)


def download_event_data_in_FD(detectors,
                              time_event,
                              time_segment,
                              time_buffer,
                              window,
                              num_segments_psd):

    data = {'waveform': {}, 'asds': {}}
    for det in detectors:
        print('Detector {:}:'.format(det))

        data['waveform'][det] = download_strain_data_in_FD(
            det,
            time_event,
            time_segment,
            time_buffer,
            window
        )
        data['asds'][det] = download_psd(
            det,
            time_event + time_buffer - time_segment * (num_segments_psd + 1),
            time_segment,
            window,
            num_segments_psd
        ) ** 0.5

    # build domain object
    f_s = len(data['waveform'][detectors[0]]) / time_segment
    domain = UniformFrequencyDomain(f_min = 0, f_max = f_s / 2, delta_f = 1/time_segment,
                                    window_factor = get_window_factor(window))

    return data, domain

time_segment = 8
time_event = 1126259462.4
time_buffer = 2
num_segments_psd = 128
T_psd = 1024.0

detectors = ['H1', 'L1']

window_kwargs = {"window_type": "tukey", "f_s": 4096, "T": 8.0, "roll_off": 0.4}
window = get_window(window_kwargs)

filename = './datasets/strain_data/GW150914.hdf5'

data, domain = download_event_data_in_FD(
    detectors, time_event, time_segment, time_buffer, window, num_segments_psd
)

save_dataset(data, {'domain': domain.domain_dict}, filename)

import h5py
import ast

f = h5py.File(filename, 'r')
data = recursive_hdf5_load(f)
settings = ast.literal_eval(f.attrs['settings'])
f.close()
domain = build_domain(settings['domain'])

transforms = torchvision.transforms.Compose([
    WhitenAndScaleStrain(domain.noise_std)
    # WhitenAndScaleStrain(1)
])

a = transforms(data)

ref_strains = h5py.File('./datasets/strain_data/old_data/strain_FD_whitened.hdf5', 'r')

import matplotlib.pyplot as plt
plt.plot(a['waveform']['H1'])
plt.plot(ref_strains['H1'][:])
plt.show()

ratio = ref_strains['H1'][200:] / a['waveform']['H1'][200:8193]


d = {'waveform': {}, 'asds': {}}
for det in detectors:
    print('Detector {:}:'.format(det))

    d['waveform'][det] = download_strain_data_in_FD(det, t_event, T, T_buffer, window)
    d['asds'][det] = download_psd(det, t_event + T_buffer - T - T_psd, T, window) ** 0.5


    event_strain_FD_whitened[:int(f_min / event_strain_FD_whitened.delta_f)] = 0.0
    event_strain_FD_whitened = event_strain_FD_whitened[:int(f_max / event_strain_FD_whitened.delta_f)+1]


#
#     psd.save(join(event_dir, 'PSD_{:}.txt'.format(det)))
#
#     # store whitened strains and psds in dicts
#     whitened_FD_event_strains[det] = event_strain_FD_whitened
#     psds[det] = psd
#
# # Save whitened FD strain data
# print('Saving events strains to {:}'.format(event_dir / 'strain_FD_whitened.hdf5'))
# with h5py.File(event_dir / 'strain_FD_whitened.hdf5', 'w') as f:
#     for det in detectors:
#         strain_det = whitened_FD_event_strains[det]
#         f.create_dataset(det, data=strain_det)
#     f.create_dataset('sample_frequencies', data=np.array(strain_det.sample_frequencies.numpy()))
#
# # Save PSDs in numpy array
# print('Saving ASDs to {:}'.format(join(event_dir, 'ASDS.npy')))
# asds = {}
# for det in detectors:
#     asd = np.sqrt(np.array(psds[det][:8193]))
#     asds[det] = asd
# np.save(join(event_dir, 'ASDS.npy'), asds)


print('Done')